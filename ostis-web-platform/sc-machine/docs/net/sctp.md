# Протокол SCTP

**sctp-команда**

SCTP-команда состоит из двух частей:
* **заголовок команды** - часть команды, в которой указан её тип и некоторая дополнительная информация о ней. Заголовок команды имеет фиксированный размер.
* **аргументы** - часть команды, которая содержит её аргументы. Размер аргументов может быть разным и зависит лишь от типа команды.

Таким образом размер команды зависит от её типа.

** Заголовок sctp-команды **
Заголовок sctp-команды имеет следующую структуру:
<table>
 <tr>
  <th>Поле</th>
  <th>Размер</th>
  <th>Примечание</th>
 </tr>

 <tr>
  <td>code</td>
  <td>1 байт</td>
  <td>Используется для указания типа команды (описание команд приведено дальше)</td>
 </tr>

 <tr>
  <td>flags</td>
  <td>1 байт</td>
  <td>Используется для передачи дополнительных флагов команды (описаны далее)</td>
 </tr>

 <tr>
  <td>id</td>
  <td>4 байта</td>
  <td>Уникальный идентификатор команды (должен быть уникальным в рамках клиента, так как по нему клиент устанавливает соотвествие между результатом и конкретной командой)</td>
 </tr>

 <tr>
  <td>size</td>
  <td>4 байта</td>
  <td>Размер поля с аргументами (в байтах)</td>
 </tr>
</table>

После выполнения каждой sctp-команды возвращается результат, который привязан к id команды. Так как команда выполняется асинхронно, то результат может может быть возвращен в любой момент. Схема выполнения команды выглядит следующим образом:

![Структура sc-машины](http://github.com/deniskoronchik/sc-machine/wiki../../images/sctp/command_cycle.png)

**Важно**: протокол является двусторонним. Другими словами часть команд может быть отправлена сервером клиенту, в тот момент, когда клиент ожидает ответ на запрос. Сервер гарантирует целостность сообщений, но не гарантирует порядок их прихода.

**sctp-результат**

SCTP-результат состоит из двух частей:
* **заголовок результата** - часть результата, в которой указан его тип и некоторая дополнительная информация о нем. Заголовок результата имеет фиксированный размер.
* **значения** - часть результата, которая содержит возвращаемые значения. Размер этого поля может быть разным и зависит лишь от типа результата.

Таким образом размер реузльтата зависит от его типа. Тип результата всегда совпадает с типом команды которой соотвествует этот результат.

Заголовок sctp-результата имеет следующую структуру:
<table>
 <tr>
  <th>Поле</th>
  <th>Размер</th>
  <th>Примечание</th>
 </tr>

 <tr>
  <td>code</td>
  <td>1 байт</td>
  <td>Тип команды к которой возвращается результат</td>
 </tr>

 <tr>
  <td>id</td>
  <td>4 байта</td>
  <td>Уникальный идентификатор команды которой соответствует этот результат</td>
 </tr>

 <tr>
  <td>return</td>
  <td>1 байт</td>
  <td>Код возврата - один из базовых кодов возврата, который говорит об успешности выполнения команды или в противном случае содержит код ошибки</td>
 </tr>

 <tr>
  <td>size</td>
  <td>4 байта</td>
  <td>Размер поля с результатами (в байтах)</td>
 </tr>

</table>

Таблица кодов возврата:
<table>
 <tr>
  <th>Код</th>
  <th>Описание</th>
 </tr>

 <tr>
  <td>0x00</td>
  <td>Успешное выполнение команды</td>
 </tr>

 <tr>
  <td>0x01</td>
  <td>Безуспешное выполнение команды</td>
 </tr>

 <tr>
  <td>0x02</td>
  <td>Указанный sc-элемент не найден (не верный sc-адрес)</td>
 </tr>


 <tr>
  <td>0x03</td>
  <td>Не достаточно прав доступа для выполнения команды</td>
 </tr>

</table>

<b>Важно: </b>если sctp-команда выполнена с ошибкой то sctp-результат состоит лишь из заголовка

Таблица базовых шаблонов поиска:
<table>
 <tr>
  <th>Код</th>
  <th>Шаблон</th>
 </tr>

 <tr>
  <td>0</td>
  <td>3f_a_a</td>
 </tr>

 <tr>
  <td>1</td>
  <td>3a_a_f</td>
 <tr>

 <tr>
  <td>2</td>
  <td>3f_a_f</td>
 <tr>

 <tr>
  <td>3</td>
  <td>5f_a_a_a_f</td>
 <tr>

 <tr>
  <td>4</td>
  <td>5_a_a_f_a_f</td>
 <tr>

 <tr>
  <td>5</td>
  <td>5_f_a_f_a_f</td>
 <tr>

 <tr>
  <td>6</td>
  <td>5_f_a_f_a_a</td>
 <tr>

 <tr>
  <td>7</td>
  <td>5_f_a_a_a_a</td>
 <tr>

 <tr>
  <td>8</td>
  <td>5_a_a_f_a_a</td>
 <tr>

</table>

Таблица кодов событий:

<table>
 <tr>
  <th>Код</th>
  <th>Событие</th>
 </tr>

 <tr>
  <td>0</td>
  <td>Добавление выходящей дуги (ребра)</td>
 </tr>

 <tr>
  <td>1</td>
  <td>Добавление входящей дуги (ребра)</td>
 </tr>

 <tr>
  <td>2</td>
  <td>Удаление выходящей дуги (ребра)</td>
 </tr>

 <tr>
  <td>3</td>
  <td>Удаление входящей дуги (ребра)</td>
 </tr>

 <tr>
  <td>4</td>
  <td>Удаление sc-элемента</td>
 </tr>

 <tr>
  <td>5</td>
  <td>Изменение содержимого sc-ссылки</td>
 </tr>

</table>

Далее перечислены коды всех команд с описанием их аргументов и результатов:
<br/><br/>
<b>Код:</b> 0x01 <br/>
<b>Команда:</b> Проверка существования элемента с указанным sc-адресом <br/>
<b>Аргументы:</b> <i>4 байта</i> - sc-адрес проверяемого sc-элемента <br/>
<b>Результат:</b> Результат выполнения лежит в возвращаемом коде. Если там код успешного выполнения, то элемент с указанным sc-адресом существует, иначе возвращается код ошибки.<br/>
<hr/>

<b>Код:</b> 0x02<br/>
<b>Команда:</b> Получение типа sc-элемента по sc-адресу<br/>
<b>Аргументы:</b> <i>4 байта</i> - sc-адрес элемента для получения типа<br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращаются 2 байта обозначающих тип sc-элемента. Иначе размер поля с результатами равен нулю (результатов нет)<br/>
<hr/>

<b>Код:</b> 0x03<br/>
<b>Команда:</b> Удаление sc-элемента с указанным sc-адресом<br/>
<b>Аргументы:</b> <i>4 байта</i> - sc-адрес удаляемого sc-элемента<br/>
<b>Результат:</b> Команда возвращает лишь код удачного выполнения, если элемент удален успешно, иначе возвращается код ошибки.<br/>

<hr/>
<b>Код:</b> 0x04<br/>
<b>Команда:</b> Создание нового sc-узла указанного типа<br/>
<b>Аргументы:</b> <i>2 байта</i> - тип создаваемого sc-узла<br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращаются <i>4 байта</i> обозначающих адрес созданного sc-узла. Иначе размер поля с результатами равен нулю (результатов нет)<br/>
<hr/>

<b>Код:</b> 0x05<br/>
<b>Команда:</b> Создание новой sc-ссылки<br/>
<b>Аргументы:</b> нет<br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращаются <i>4 байта</i> обозначающих адрес созданной sc-ссылки. Иначе размер поля с результатами равен нулю (результатов нет)<br/>
<hr/>

<b>Код:</b> 0x06<br/>
<b>Команда:</b> Создание новой sc-дуги указанного типа, с указнным начальным и конечным элементами<br/>
<b>Аргументы:</b><br/>
   <i>2 байта</i> - тип создаваемой sc-дуги<br/>
   <i>4 байта</i> - sc-адрес начального элемента sc-дуги<br/>
   <i>4 байта</i> - sc-адрес конечного элемента sc-дуги
<br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращаются <i>4 байта</i> обозначающих адрес созданной sc-дуги. Иначе размер поля с результатами равен нулю (результатов нет)<br/>
<hr/>

<b>Код:</b> 0x07<br/>
<b>Команда:</b> Получение начального и конечного элемента sc-дуги<br/>
<b>Аргументы:</b> <i>4 байта</i> - sc-адрес дуги у которой необходимо получить начальный и конечный элемент<br/>
<b>Результат:</b> </br>
<i>4 байта</i> - sc-адрес начального элемента дуги <br/>
<i>4 байта</i> - sc-адрес конечного элементе дуги <br/>
<hr/>

<b>Код:</b> 0x08<br/>
<b>Команда:</b> <br/>
<b>Аргументы:</b><br/>
<b>Результат:</b><br/>
<hr/>

<b>Код:</b> 0x09<br/>
<b>Команда:</b> Получение содержимого sc-ссылки<br/>
<b>Аргументы:</b> <i>4 байта</i> - sc-адрес ссылки для получения содержимого<br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве размера поля с результатми возвращается размер содержимого, а качестве данных выступает само модержимое. Иначе размер поля с результатами равен нулю (результатов нет)<br/>
<hr/>

<b>Код:</b> 0x0a<br/>
<b>Команда:</b> Поиск всех sc-ссылок с указанным содержимым<br/>
<b>Аргументы:</b> <br/>
   <i>4 байта</i> - N (размер содержимого в байтах) <br/>
   <i>N байт</i> - содержимое для поиска <br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращается: <br/>
   <i> N </i>- количество найденных sc-ссылок (4 байта) <br/>
   <i> N sc-адресов </i> - найденные sc-ссылки. <br/>
<hr/>

<b>Код:</b> 0x0b<br/>
<b>Команда:</b> Установка содержимого sc-ссылки<br/>
<b>Аргументы:</b> <br/>
   <i>4 байт</i> - sc-адрес ссылки <br/>
   <i>4 байт</i> - размер содержимого в байтах <br/>
   <i>N байт</i> - данные устанавливаемого содержимого <br/>
<b>Результат:</b> Результат выполнения лежит в возвращаемом коде. Если там код успешного выполнения, то содержимое установлено, иначе возвращается код ошибки. <br/>
<hr/>

<b>Код:</b> 0x0c<br/>
<b>Команда:</b> Найти конструкции по указанному 3-х или 5-ти элементному шаблону<br/>
<b>Аргументы:</b> 
   <i>1 байт</i> - тип шаблонной конструкции для поиска <br/>
   <i>N байт</i> - аргументы для постановки в шаблон для поиска. Зависят от 
    шаблона поиска. К примеру, для шаблона 3f_a_a они будут следующие: 4 байта - адрес начального sc-элемента; 2 байта тип искомой дуги; 2 байта тип конечного sc-элемента. Другими словами каждому <i>f</i> в шаблоне поиска соответсвует sc-адрес (4 байта), а каждому <i>a</i> тип sc-элемента (2 байта) <br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращается <br/>
   <i> 4 байта </i> - количество найденных, по указанному шаблону, конструкций <br/>
   <i> N байт </i>, в которых хранятся найденные коснтрукции. К примеру, если найдено <i>K</i> конструкций соотвествующие указанному шаблону, то <i>N = T * K * 4 байт</i>, где T - количество аргументов в искомом шаблоне, для 3-х элементных конструкций оно равно 3, для 5-ти элементных - 5. В результатах лежат последовательно все найденные конструкции, они задаются sc-адресами найденых sc-элементов.<br/>
<hr/>

<b>Код:</b> 0x0d<br/>
<b>Команда:</b> Итерирование сложных конструкций (<b>улучшить описание</b>)<br/>
<b>Аргументы:</b> <br/>
   <i> 1 байт </i> - количество итераторов <b>(max 50)</b><br/>
   <i> N байт </i> - данные итераторов <br/>
   Каждый итератор описывается следующей структурой: <br/>
   <i> 1 байт </i> - тип итератора <br/>
   <i> nF байт </i> - правила подстановки (<b><i>Для первого итератора этих правил нет</i></b>). Правило подстановки это номер адреса в результате, который необходимо подставить в качестве аргумента итератора (255 - отсутсвующая подстановка). Результаты последовательного выполнения итераторов попадают в общий массив. Другими словами если у нас есть два итератора 3-х и 5-ти элементных конструкций, то номер адреса 4 даст первый элемент 5-ти элементной конструкции. nF - это количество известных аргументов итератора (fixed), nA - количество неизвестных аргументов итератора (assign). Итераторы выполняются последовательно, поэтому номер подстановки должен быть меньше количества аргументов итераторов до этого. <br/>
   <i> (nF - k) * 4 + nA * 2 байт </i> - все подстановки, пропускаются, их нет необходимости указывать (k - количество подстановок) <br/>
<b>Результат:</b> <br/>
   <i> 4 байта </i> - количество результатов (<b>rCount</b>)<br/>
   <i> N байт </i> - результаты итерирования. N = 4 * rCount * k, где k - сумма аргументов всех итераторов в запросе (для примера с двумя итераторами 3-х и 5-ти элементных конструкций, k = 8) <br/>
<hr/>

<b>Код:</b> 0x0e<br/>
<b>Команда:</b> Создание подписки на событие<br/>
<b>Аргументы:</b> <br/> 
   <i>1 байт</i> - тип события <br/>
   <i>4 байта</i> - адрес sc-элемента для подписки на событие<br/>
<b>Результат:</b> В случае, если подписка на событие произведена успешно, то возвращается id подписки состоящий из <i>4 байт</i>. Если же подписаться на событие не удалось, то возвращается лишь заголовок ответа, который содержит код ошибки.<br/>
<hr/>

<b>Код:</b> 0x0f<br/>
<b>Команда:</b> Удаление подписки на событие<br/>
<b>Аргументы:</b> <i>4 байта</i> - id подписки, которую необходимо удалить<br/>
<b>Результат:</b> В результате неудачнго выполнения запроса возвращается только заголовок с кодом ошибки. Если же запрос обработан без ошибок, то в заголовке будет код удачного выполнения а в результате будет <i>4 байта</i> - id подписки, которая удалена<br/>
<hr/>

<b>Код:</b> 0x10<br/>
<b>Команда:</b> Запрос произошедших событий<br/>
<b>Аргументы:</b> нет<br/>
<b>Результат:</b> Если запрос обработан успешно, то в результате содержится количество произошедших событий <i>4 байта</i> и описание всех этих событий. Каждое из которых описывается следующей последовательностью байт: <br/>
   <i>4 байта</i> - id события <br/>
   <i>4 байта</i> - адрес sc-элемента событие с которым произошло <br/>
   <i>4 байта</i> - аргумент события (адрес sc-дуги, которая была удалена/создана (для событий генерации/удаления дуги))<br/>
<hr/>

<b>Код:</b> 0x11<br/>
<b>Команда:</b> Генерация сложных конструкций (<b>улучшить описание</b>). Параметры задаются также как и в итерировании сложных конструкций, только вместо поиска осуществляется их генерация. <b>Важно! Команда не проверяет наличие уже существующих конструкций по указанным шаблонам!</b><br/>
<b>Аргументы:</b> <br/>
   <i> 1 байт </i> - количество итераторов/шаблонов <b>(max <= 50)</b><br/>
   <i> N байт </i> - данные итераторов/шаблонов <br/>
   Каждый итератор описывается следующей структурой: <br/>
   <i> 1 байт </i> - тип итератора <br/>
   <i> nF байт </i> - правила подстановки (<b><i>Для первого итератора этих правил нет</i></b>). Правило подстановки это номер адреса в результате, который необходимо подставить в качестве аргумента итератора (255 - отсутсвующая подстановка). Результаты последовательного выполнения итераторов попадают в общий массив. Другими словами если у нас есть два итератора 3-х и 5-ти элементных конструкций, то номер адреса 4 даст первый элемент 5-ти элементной конструкции. nF - это количество известных аргументов итератора (fixed), nA - количество неизвестных аргументов итератора (assign). Итераторы выполняются последовательно, поэтому номер подстановки должен быть меньше количества аргументов итераторов до этого. <br/>
   <i> (nF - k) * 4 + nA * 2 байт </i> - все подстановки, пропускаются, их нет необходимости указывать (k - количество подстановок) <br/>
<b>Результат:</b> <br/>
   <i> N байт </i> - результаты генерации N = 4 * k, где k - сумма аргументов всех итераторов в запросе (для примера с двумя итераторами 3-х и 5-ти элементных конструкций, k = 8) <br/>
<hr/>

<b>Код:</b> 0xa0<br/>
<b>Команда:</b> Поиск sc-элемента по его системному идентификатору<br/>
<b>Аргументы:</b> <br/>
   <i>4 байта</i> - N (размер идентификатора в байтах) <br/>
   <i>N байт</i> - данные идентификатора <br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращаются <i>4 байта</i> обозначающих адрес найденого sc-эелемента. Иначе размер поля с результатами равен нулю (результатов нет)<br/>
<hr/>

<b>Код:</b> 0xa1<br/>
<b>Команда:</b> Установка системного идентификатора sc-элемента<br/>
<b>Аргументы:</b> <br/>
   <i>4 байта</i> - адрес sc-элемента <br/>
   <i>4 байта</i> - N (размер идентификатора в байтах) <br/>
   <i>N байт</i> - данные идентификатора <br/>
<b>Результат:</b> <br/>
<hr/>

<b>Код:</b> 0xa2<br/>
<b>Команда:</b> Получение статистики с сервера, в ременных границах. Время используется в формате http://en.wikipedia.org/wiki/Unix_time<br/>
<b>Аргументы:</b> <br/>
   <i>8 байт</i> - Нижняя временная граница <br/>
   <i>8 байт</i> - Верхняя временная граница <br/>
<b>Результат:</b> Если выполнение команды успешно, то в качестве результата возвращаются <i>4 байта</i> обозначающих количество временных отметок результаты которых возвращаются. Каждая такая временная отметка состоит из следуюзик полей: <br/>
   <i>8 байт</i> - Время сбора статистики<br/>
   <i>8 байт</i> - Общее количество sc-узлов, которые есть в sc-памяти<br/>
   <i>8 байт</i> - Общее количество sc-дуг, которые есть в sc-памяти<br/>
   <i>8 байт</i> - Общее количество sc-ссылок, которые есть в sc-памяти<br/>
   <i>8 байт</i> - Количество пустых ячеек в sc-памяти<br/>
   <i>8 байт</i> - Общее количество подключений клиентов к sctp серверу (не активных, а общее число включая и завершенные)<br/>
   <i>8 байт</i> - Количество обработанных sctp команд (включая обработанные с ошибками)<br/>
   <i>8 байт</i> - Количество обработанных с ошибками sctp команд<br/>
   <i>1 байт</i> - Флаг начального сбора статистики. Другими словами, если это значание равно 1, то статистика была собрана при запуске sctp сервера. Если значание равно 0, то статистика собрана уже во время работы сервера<br/>
<hr/>

<b>Код:</b> 0xa3<br/>
<b>Команда:</b> Получение версии протокола<br/>
<b>Аргументы:</b> нет<br/>
<b>Результат:</b> Если команда выполнена успешно, то в качестве результата возвращается <i>4 байта</i>, которые обозначают версию используемого сервером sctp протокола. (способ кодирования версии необходимо уточнить)<br/>
<hr/>
